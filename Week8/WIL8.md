WIL8

<수업내용 간단하게>
아 사이트도 유저가 능력을 넣어주는 것에 대해서 적절한 대응을 할 수 없을까? -> 프로그래밍 언어를 넣자!

CSS, HTML은 각각 프로그래밍 언어가 아님 -> 로직을 실행할 수 있는 JavaScript가 들어가면 통합적으로 프로그래밍 언어로 볼 수 있음

정적인 웹사이트를 넘어서 프로그램처럼 작용하고 싶다 -> JavaScript 등장

코드 실행 가능 -> 상호 작용 가능, 데이터 송수신 가능, DOM 조정 가능

왜 javascript 인가? -> java가 웹 서버용 언어로 잘 나가고 있었음. -> javascript를 만드는 회사가 부러워해서 javascript라고 명함 -> java의 경량형 버전, 같은 회사 제품인 줄 알았음

경량형, 보조형이라서 굉장히 문제가 많고, 알아보기 어려웠음

ECMAScript 6 + 이 이상은 학습하는 것이 좋음

JavaScript가 태생은 원숭이었으나, 5나 6는 사용하기 많이 좋아졌음 -> 프론트엔드 지망 시 let, const 등등의 기능을 알면 좋음

framework = 어느 정도의 제어를 맡김.

프론트 엔드 지망 -> ECMAScript 5, 6+

node.js / TS(javascript 포함하고 더 많은 내용이 포함됨. microsoft)

변수 -> ‘var’ 로 선언 -> int, float, char 상관 X – 재선언 O, 재할당 O, Function Scope
‘let’로도 선언 O, 재선언X, 재할당 O , Block Scope – 중괄호로 묶인 영역(Block) -> Block 안에서만 존재할 수 있고, 벗어나면 변수가 메모리에 할당 되는 것이 사라짐
‘const’ -> 재선언X, 재할당 X, Block Scope
var example1 = 10; (변수 선언 + 값 할당)
console.log(변수 이름); -> 변수에 있는 값을 읽어줌
자료형 -> 결국 0과 1로 표현 -> 데이터는 크기가 다름 -> javascript가 암묵적으로 알아서 판단을 하여 알아서 자료형 선언을 함 + 데이터 크기도 결정
선언만 하고 값 할당 안함 -> undefined

-> var 쓰지 말자! 코딩에 방해된다!
변하지 않는 상수를 쓰자! 변하지 않는 것, 확실한 것이 좋은 경우가 많다!

TS는 프로그래머가 직접 명확하게 말하도록 함

암시적 형 변환

“0” 두 자료형이 다른 변수를 암시적으로 다른 한 쪽을 변화시켜버림(오른쪽 것을 왼쪽 것으로)

빈 배열 -> 숫자랑 비교하면, Number라는 함수를 호출해서 괄호 안에 있는 함수를 숫자로 바꿈 ex) Number([]); -> 0

3개짜리가 나옴 === -> 값 뿐만 아니라 타입까지 비교함

if문, for문, while 문 -> 흐름 제어

<과제>

프로그래밍 = 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션 -> 문제 해결 능력이 필요(알고리즘은 도움을 주는 것) = 0과 1밖에 알지 못하는 기계가 실행할 수 있는 정도로 정확하고 상세하게 요구사항을 설명하는 작업 = 변수를 통해 값을 저장하고 참조하며 연산자로 값을 연산, 평가하고 조건문과 반복문에 의한 흐름제어로 데이터의 흐름을 제어하고 함수로 재사용이 가능한 구문의 집합을 만들며 객체, 배열 등으로 자료를 구조화하는 것 =>프로그래밍은 요구사항의 집합을 분석하여 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것 ->기본 개념과 동작 원리를 정확히 이해하는 것이 중요

일종의 번역기 = 컴파일러(compiler) 혹은 인터프리터(interpreter)
프로그래밍 언어는 Syntax(구문)와 Semantics(의미)의 조합으로 표현됨

-변수 = 위치(메모리 상의 주소)를 기억하는 저장소 = 메모리 주소에 접근하기 위한 식별자 : 값(value)을 저장(할당)하고 그 저장된 값(유지(캐싱)할 필요가 있는 값)을 참조하기 위해 사용 -> 변수 이름을 통해 의미 명확히 알 수 O, 코드 가독성 상승
var 키워드로 객체도 선언 O

리터럴(literal) = 소스코드 안에서 직접 만들어 낸 상수 값 자체를 말하며 값을 구성하는 최소 단위 ex) 숫자, 문자열, boolean, null, undefined, 객체, 배열, 정규 표현식, 함수 등

javascript의 datatype : 원시 – number, string, boolean, null, undefined, symbol. 객체 – object (배열, 함수도 변수에 할당할 수 O)

주의 한번 할 연산자 : 문자열 연결 연산자(‘???’ + ‘??!’ ), 타입 연산자(typeof ‘HI’ -> string), 인스턴스 생성 연산자(= new Date(); -> 한국 표준 시간이 나옴)

자바스크립트는 암묵적 타입 강제 변환을 통해 연산을 수행함

var : 새로운 변수를 생성할 것을 지시

주석 : //(한줄) 또는 /\* \*/(여러줄)

문은 코드블록 ( { ... } )으로 그룹화 할 수 있다. -> 함께 실행되어야 하는 문을 정의하기 위함

표현식(Expression)은 하나의 값으로 평가(Evaluation)됨
문(Statement)이 마침표로 끝나는 하나의 완전한 문장(Sentence)이라고 한다면 표현식은 문을 구성하는 요소

함수 = 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록. 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 O

자바스크립트는 동적 타입(Dynamic/Weak Type) 언어 -> 변수의 타입 지정 없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정(타입 추론, Type Inference)됨. => 변수는 고정된 타입이 없음 -> 같은 변수에 여러 타입의 값을 자유롭게 할당할 수 O

원시 타입의 값 = 변경 불가능한 값(immutable value), pass-by-value(값에 의한 전달)

-number : ECMAScript 표준에 따르면, 숫자 타입의 값은 배정밀도 64비트 부동소수점 형(double-precision 64-bit floating-point format : -(2^53 -1) 와 2^53 -1 사이의 숫자값)을 따른다. 즉, 모든 수를 실수를 처리하며 정수만을 표현하기 위한 특별한 데이터 타입(integer type)은 없다.

진수, 8진수, 16진수 리터럴은 메모리에 동일한 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.

자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수를 처리한다. 정수로 표시된다해도 사실은 실수다. 따라서 정수로 표시되는 수 끼리 나누더라도 실수가 나올 수 있다.

Infinity : 양의 무한대 (n / 0)
-Infinity : 음의 무한대 (n / -0)
NaN : 산술 연산 불가(not-a-number) (1 \* ‘string’ )

-string : 텍스트 데이터를 나타내는데 사용.(가장 일반적인 표기법 = 작은 따옴표 사용) 원시 타입이며 변경 불가능(immutable) = 한 번 문자열이 생성되면, 그 문자열을 변경할 수 X( ex. 변수 str은 문자열 ‘Hello’를 가리키고 있다가 문자열 ‘world’를 가리키도록 변경). 유사 배열 -> dlal 생성된 문자열의 일부 문자를 변경해도 반영 X. 재할당 O.

str = str.substring(0, 3); 앞의 3글자 읽기
str = str.toUpperCase(); 글지를 대문자로 읽기

-boolean : 비어있는 문자열 null, undefined, 숫자 0 은 주로 false로 간주

-undefined : undefined 타입의 값은 undefined가 유일. 선언 이후 값을 할당하지 않은 변수는 undefined 값을 가짐. = 선언은 되었지만 값을 할당하지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우 undefined가 반환

변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태(대부분 비어있지 않고 쓰레기 값(Garbage value)이 들어 있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화하기 때문(자바스크립트 엔진에 의해 초기화된 값)

\*변수의 값이 없다는 것을 명시하고 싶은 경우 -> null 할당

-null : null 타입의 값은 null이 유일(null은 Null, NULL등과 다름). 의도적으로 변수에 값이 없다는 것을 명시할 때 사용, 참조 정보를 제거하는 것을 의미, 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우, 명시적으로 null을 반환

\*입을 나타내는 문자열을 반환하는 typeof 연산자로 null 값을 연산해 보면 null이 아닌 object가 나온다. 이는 자바스크립트의 설계상의 오류임 -> null 타입을 확인할 때 typeof 연산자를 사용하면 안되고 일치 연산자(===)를 사용하여야 함.

-symbol : 변경 불가능한 원시 타입의 값. 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용.

심볼은 Symbol 함수를 호출해 생성한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다.

-객체 :　이름과 값을 가지는 데이터를 의미하는 프로퍼티(property)와 동작을 의미하는 메소드(method)를 포함할 수 있는 독립적 주체. pass-by-reference(참조에 의한 전달)

-변수 : 프로그램에서 사용되는 데이터를 일정 기간 동안 기억하여 필요한 때에 다시 사용하기 위해 데이터에 고유의 이름인 식별자(identifier)를 명시한 것
var, let, const 키워드로 선언, 할당 연산자를 통해 값 할당, 변수명을 사용해 변수에 저장된 값을 참조

변수명 : 반드시 영문자(특수문자 제외), underscore ( \_ ), 또는 달러 기호($)로 시작. 자바스크립트는 대/소문자를 구별

변수 -> ‘var’ 로 선언 -> int, float, char 상관 X – 재선언 O, 재할당 O, Function Scope
‘let’로도 선언 O, 재선언X, 재할당 O , Block Scope – 중괄호로 묶인 영역(Block) -> Block 안에서만 존재할 수 있고, 벗어나면 변수가 메모리에 할당 되는 것이 사라짐
‘const’ -> 재선언X, 재할당 X, Block Scope

자바스크립트는 동적 타입(dynamic/weak type) 언어 = 변수의 타입 지정(Type annotation)없이 값이 할당되는 과정에서 값의 타입에 의해 자동으로 타입이 결정(Type Inference)됨 = 같은 변수에 여러 타입의 값을 할당할 수 O

변수 호이스팅(Variable Hoisting) = var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성 = 자바스크립트는 모든 선언문(var, let, const, function, function\*, class)이 선언되기 이전에 참조 가능 = 모든 선언문은 호이스팅(Hoisting)된다. = var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어짐 -> 스코프에 변수가 등록되고 변수는 메모리에 공간을 확보한 후 undefined로 초기화 -> 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않고 undefined를 반환

자바스크립트 - 블록 레벨 스코프(block-level scope)를 가지지 않고 함수 레벨 스코프(function-level scope)를 가짐. but, let, const 키워드 사용 -> 블록 레벨 스코프 사용 O

함수 레벨 스코프(Function-level scope) : 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. -> 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.
블록 레벨 스코프(Block-level scope) : 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.

var 키워드 -> 전역변수로 인해서 문제가 발생할 수 O. 유효 범위(scope)가 넓어서 어디에서 어떻게 사용될 지 파악하기 힘듦(의도하지 않은 변수 변경이 발생할 수 있음), 여러 함수와 상호 의존하는 등 부수효과 있을 수 있음 -> 복잡성 증가
{함수 레벨 스코프(Function-level scope) : 전역 변수의 남발, for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 O
var 키워드 생략 허용 : 의도하지 않은 변수의 전역화
중복 선언 허용 : 의도하지 않은 변수값 변경
변수 호이스팅 : 변수를 선언하기 전에 참조가 가능 }

=> 변수의 유효 범위(scope)는 좁을수록 좋음 -> let, const 키워드 사용 권장

표현식 : 리터럴, 식별자, 연산자, 함수 호출 등의 조합 -> 평가되어 하나의 값을 만듦
ex) 리터럴, 식별자, 연산자, 함수/메소드 호출 -> 평가되어 하나의 값을 만듦

문(statement) : 자바스크립트 엔진에게 내리는 명령 -> 세미콜론(;)으로 끝나야 함(코드블록 예외)
ex) 변수 선언문, 할당문, 함수 선언문, 조건문, 반복문

문의 끝에 붙이는 세미콜론은 옵션으로 쓰지 않아도 상관없다. 자바스크립트 엔진이 스크립트를 해석할 때, 자바스크립트 엔진에는 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 있기 때문이다.

자바스크립트의 모든 코드 = 문 or 표현식.
문 : 마침표로 끝나는 하나의 완전한 문장(Sentence). 문은 var, let, const, function, class와 같은 선언 키워드를 사용하여 변수나 함수를 생성하기도 하고 if, for, while 문과 같은 제어문을 생성하여 프로그램의 흐름을 제어하기도 함. 문의 역할은 표현식으로 생성한 값을 사용해 컴퓨터에게 명령을 내리는 것. 문에는 표현식인 문과 표현식이 아닌 문이 있음

표현식 : 문을 구성하는 요소. 표현식은 그 자체로 하나의 문이 될 수 O. 표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 X. 표현식의 역할은 값을 생성하는 것

ex) 할당문은 표현식인 문. 선언문은 표현식이 아닌 문.

연산자 : ++x vs x++ (전위 증가 = 증가 후 다른 연산 vs 후위 증가 = 다른 연산 후 증가)

비교 연산자 : ==(동등 비교 연산자) vs ===(일치 비교 연산자) , !=(부등 비교 연산자) vs !==(불일치 비교 연산자) (값이 같은지 다른지 vs 값과 타입이 같은지 다른지)

NaN은 자신과 일치하지 않는 유일한 값 -> 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용, 숫자 0도 주의

삼항 조건 연산자 -> 조건 ? 참일 때 값 : 거짓일 때 값;

논리 연산자 : || , && , ! (AND, OR 연산자의 연산 결과는 boolean 값이 아닐 수 O)

typeof 연산자 : 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환
typeof 연산자로 null 값을 연산해 보면 null이 아닌 “object”를 반환 -> null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용
선언하지 않은 식별자 -> typeof 연산자 연산 -> ReferenceError가 발생 X, undefined 반환

블록문(Block statement/Compound statement) : 0개 이상의 문들을 중괄호로 묶은 것. 코드 블록 또는 블록. 자바스크립트는 블록문을 하나의 단위로 취급. 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수 선언문 등에서 사용. 세미콜론을 붙이지 않음

조건문 : if else 문, switch 문

if else 문 : 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별. 삼항 조건 연산자로 바꿔쓸 수 있음
switch 문 : 현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동. 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용. 표현식과 일치하는 표현식을 갖는 case 문이 없다면 실행 순서는 default 문으로 이동(사용하지 않아도 됨) + 마지막에 break 문을 사용(default는 필요 X) -> 코드 블록에서 탈출

반복문 : for문, while 문, do while 문

`[${i}, ${j}]` -> 출력 [n, m]

while문 : 건식의 평가 결과가 언제나 참이면 무한루프 -> if문 + break 문 사용 -> 코드 블록 탈출

break문 : 레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출

레이블 문(Label statement) : 식별자가 붙은 문. 실행 순서를 제어하기 위해 사용.( switch 문의 case 문과 default 문) -> 탈출을 위해 break문에 레이블 지정
ex) foo: console.log(‘foo’); -> break foo;

continue 문 : 반복문(for, for…in, for…of, while, do…while)의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동. if 문 내에서 실행해야 할 코드가 길다면 들여쓰기가 한 단계 더 깊어지므로 continue 문을 사용하는 것이 가독성이 더 좋음

타입 변환과 단축 평가

명시적 타입 변환(Explicit coercion) 또는 타입 캐스팅(Type casting) : 개발자에 의해 의도적으로 값의 타입을 변환하는 것
암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion) : 동적 타입 언어인 자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 함

명시적 타입 변환도 마찬가지지만, 암묵적 타입 변환이 기존 값(위 예제의 경우, 변수 x의 값)을 직접 변경하는 것은 아니다. “변수”에서 살펴보았듯이 변수 값이 원시 타입의 값인 경우, 변수 값을 변경하려면 재할당을 통해 새로운 메모리 공간을 확보하고 그 곳에 원시 값을 저장한 후 변수명이 재할당된 원시 값이 저장된 메모리 공간의 주소를 기억하도록 해야 한다.

암묵적 타입 변환은 변수 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을 에러없이 평가하기 위해 기존 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.

자바스크립트 엔진은 표현식을 평가할 때 문맥, 컨텍스트(Context)에 고려하여 암묵적 타입 변환을 실행

문자열 타입으로 변환
1 + '2' // "12“

- 연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작 -> 문자열 값을 만듦 -> 피연산자는 문맥 상 문자열 타입이어야함

숫자 타입으로 변환
1 - '1' // 0 , 1 \* '10' // 10 , 1 / 'one' // NaN
-> 산술 연산자로 취급 -> 숫자값을 만듦 -> 피연산자는 문맥상 숫자 타입이어야함
ex) 비교 연산자,

boolean 타입으로 변환
falsy -> false로 변환 ex) false, undefined, null, 0, -0, NaN, ”(빈 문자열) -> 이외의 값은 모두 true로 평가되는 truthy 값임

명시적 타입 변환

문자열 타입으로 변환 - String 생성자 함수를 new 연산자 없이 호출하는 방법, Object.prototype.toString 메소드를 사용하는 방법, 문자열 연결 연산자를 이용하는 방법

숫자 타입으로 변환 - Number 생성자 함수를 new 연산자 없이 호출하는 방법, parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능), 단항 연결 연산자를 이용하는 방법, 산술 연산자를 이용하는 방법

boolean 타입으로 변환 - Boolean 생성자 함수를 new 연산자 없이 호출하는 방법, ! 부정 논리 연산자를 두번 사용하는 방법

단축 평가

논리 연산자 = 오른쪽에서 왼쪽으로 평가
ex) 'Cat' && 'Dog' // “Dog” -> 논리곱 연산의 결과를 결정한 것은 두 번째 피연산자인 ‘Dog’임 -> 문자열 ‘Dog’를 그대로 반환

ex) 'Cat' || 'Dog' // 'Cat' -> 논리 연산의 결과를 결정한 것은 첫 번째 피연산자인 ‘Cat’ -> 문자열 ‘Cat’를 그대로 반환

true || anything -> true
false || anything -> anything
true && anything -> anything
false && anything -> false

객체가 null인지 확인하고 프로퍼티를 참조할 때 : 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합 -> 만약 객체가 null인 경우, 객체의 프로퍼티를 참조하면 타입 에러(TypeError)가 발생 => 단축 평가를 사용하면 에러를 발생 X

함수의 인수(argument)를 초기화할 때 : 함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 가짐 => 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러 방지

프로토타입 객체

자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어.

클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 이를 통해 객체(인스턴스)를 생성함. but, 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이(Class-less)도 객체를 생성할 수 O

자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있음 -> 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 함 -> 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 Prototype(프로토타입)이라 함. Prototype 객체는 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용함

ECMAScript spec에서는 자바스크립트의 모든 객체는 [[Prototype]]이라는 인터널 슬롯(internal slot)를 가진다. [[Prototype]]의 값은 null 또는 객체이며 상속을 구현하는데 사용된다. [[Prototype]] 객체의 데이터 프로퍼티는 get 액세스를 위해 상속되어 자식 객체의 프로퍼티처럼 사용할 수 있다. 하지만 set 액세스는 허용되지 않는다.

[[Prototype]]의 값은 Prototype(프로토타입) 객체이며 **proto** accessor property로 접근할 수 있다. **proto** 프로퍼티에 접근하면 내부적으로 Object.getPrototypeOf가 호출되어 프로토타입 객체를 반환한다.

student 객체는 **proto** 프로퍼티로 자신의 부모 객체(프로토타입 객체)인 Object.prototype을 가리키고 있다.

객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.

[[Prototype]] vs prototype 프로퍼티

모든 객체는 자신의 프로토타입 객체를 가리키는 [[Prototype]] 인터널 슬롯(internal slot) 을 갖으며 상속을 위해 사용된다. 함수도 객체이므로 [[Prototype]] 인터널 슬롯을 갖는다. 그런데 함수 객체는 일반 객체와는 달리 prototype 프로퍼티도 소유하게 된다.

_주의_ prototype 프로퍼티는 프로토타입 객체를 가리키는 [[Prototype]] 인터널 슬롯은 다르다는 것이다. prototype 프로퍼티와 [[Prototype]]은 모두 프로토타입 객체를 가리키지만 관점의 차이가 있다.

[[Prototype]] : 함수를 포함한 모든 객체가 가지고 있는 인터널 슬롯, 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리키며 함수 객체의 경우 Function.prototype를 가리킴

prototype 프로퍼티 : 함수 객체만 가지고 있는 프로퍼티, 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성될 객체의 부모 역할을 하는 객체(프로토타입 객체)를 가리킴

constructor 프로퍼티(프로토타입 객체가 가짐) : 객체의 입장에서 자신을 생성한 객체를 가리킴

function Person(name) {
this.name = name;
}

var foo = new Person('Lee');

예시 : Person() 생성자 함수에 의해 생성된 객체를 foo, foo 객체를 생성한 객체는 Person() 생성자 함수 -> foo 객체 입장에서 자신을 생성한 객체는 Person() 생성자 함수이며, foo 객체의 프로토타입 객체는 Person.prototype => 프로토타입 객체 Person.prototype의 constructor 프로퍼티는 Person() 생성자 함수를 가리킴

Prototype chain : 바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]]이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색

var student = {
name: 'Lee',
score: 90
}

// Object.prototype.hasOwnProperty()
console.log(student.hasOwnProperty('name')); // true

student 객체는 hasOwnProperty 메소드를 가지고 있지 않으므로 에러가 발생하여야 하나 정상적으로 결과가 출력 -> student 객체의 [[Prototype]]이 가리키는 링크를 따라가서 student 객체의 부모 역할을 하는 프로토타입 객체(Object.prototype)의 메소드 hasOwnProperty를 호출하였기 때문에 가능한 것

객체 생성 방법 – 객체 리터럴, 생성자 함수, Object() 생성자 함수(일반 객체와 달리 prototype 프로퍼티가 있음)

생성자 함수로 생성된 객체의 프로토타입 체인

생성자 함수 정의(함수 선언식 – 기명 함수 표현식으로 변환(자바 스크립트 엔진이 내부적으로), 함수 표현식 – 함수 리터럴 방식 사용, Function() 생성자 함수) -> 생성자 함수 객체

객체를 생성하는 방식
객체 생성 방식 엔진의 객체 생성 인스턴스의 prototype 객체
객체 리터럴 Object() 생성자 함수 Object.prototype
Object() 생성자 함수 Object() 생성자 함수 Object.prototype
생성자 함수 생성자 함수 생성자 함수 이름.prototype

프로토타입 객체의 확장
프로토타입 객체도 일반 객체와 같이 프로퍼티를 추가/삭제 O -> 즉시 프로토타입 체인에 반영

원시 타입(Primitive data type)의 확장

원시 타입은 객체가 아니므로 프로퍼티나 메소드를 가질수 없다. 하지만 원시 타입으로 프로퍼티나 메소드를 호출할 때 원시 타입과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다.

ex) String 객체의 프로토타입 객체 String.prototype에 메소드를 추가하면 원시 타입, 객체 모두 메소드를 사용할 수 있다.

Object.prototype 객체는 프로토타입 체인의 종점으로 모든 객체가 사용할 수 있는 메소드를 갖는다.

Built-in object(내장 객체)의 Global objects (Standard Built-in Objects)인 String, Number, Array 객체 등이 가지고 있는 표준 메소드는 프로토타입 객체인 String.prototype, Number.prototype, Array.prototype 등에 정의되어 있다. 이들 프로토타입 객체 또한 Object.prototype를 프로토타입 체인에 의해 자신의 프로토타입 객체로 연결한다.

자바스크립트는 표준 내장 객체의 프로토타입 객체에 개발자가 정의한 메소드의 추가를 허용한다.

프로토타입 객체의 변경

객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.

프로토타입 객체를 변경 -> 프로토타입 객체 변경 시점 이전에 생성된 객체는
기존 프로토타입 객체를 [[Prototype]]에 바인딩, 프로토타입 객체 변경 시점 이후에 생성된 객체는 변경된 프로토타입 객체를 [[Prototype]]에 바인딩

프로토타입 체인 동작 조건

객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로토타입 체인이 동작 -> 객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로토타입 체인이 동작X (객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문)

스코프

스코프 : 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙. 자바스크립트는 이 규칙대로 식별자를 찾음 -> 전역 스코프, 지역 스코프 -> 모든 변수는 스코프를 가짐 -> 전역 변수, 지역 변수

변수는 선언 위치(전역 또는 지역)에 의해 스코프를 가지게 됨 -> 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수, 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 스코프를 갖는 지역 변수.

전역 스코프를 갖는 전역 변수는 전역(코드 어디서든지)에서 참조 O, 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조 O

자바스크립트는 함수 레벨 스코프(function-level scope, 수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다))를 따름

단, let keyword 사용 -> 블록 레벨 스코프 사용 O

전역 스코프 – var 키워드로 선언한 전역 변수 -> 전역 객체 window의 프로퍼티 -> 함수 영역 밖의 전역에서 선언 => 전역에 변수를 선언하기 쉬우며 전역 변수를 남발하게 하는 문제를 야기 -> 전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드니 사용을 억제

비 블록 레벨 스코프 : 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다할지라도 모두 전역 스코프

함수 레벨 스코프 : 함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 유효하지 않다.(지역 변수. 변수명이 중복된 경우, 지역변수를 우선 참조)

렉시컬 스코프 : 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정. 자바스크립트는 렉시컬 스코프를 따름 -> 함수를 선언한 시점에 상위 스코프가 결정 => 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 X

암묵적 전역 : 자바스크립트 엔진은 y = 20을 window.y = 20으로 해석하여 프로퍼티를 동적 생성한다. 결국 y는 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작 -> y는 변수 선언 없이 전역 객체의 프로퍼티로 추가되었을 뿐 => y는 변수(delete X)가 아님, 변수 호이스팅 발생 X, delete 연산자로 삭제 O

=> 최소한의 전역변수 사용하자. 즉시실행함수를 이용한 전역변수 사용 억제하자.

var의 단점 보완 -> let, const 키워드 도입

블록 레벨 스코프를 따르는 변수를 선언하기 위해 let 키워드를 제공

let -> 변수 중복 선언 금지, 호이스팅 X(let키워드로 선언된 변수 -> 스코프의 시작에서 변수의 선언까지 일시적 사각지대 TDZ에 빠짐)

var – 선언단계와 초기화 단계가 한번에 이루어짐
let – 선언단계와 초기화 단계가 분리되어 진행됨

console.log(foo);

let foo;
console.log(foo);

foo = 1;
console.log(foo);

에서 var과 let의 차이 생각하기. 맨 처음에 일어나는 것이 선언 단계 -> 초기화는 let은 변수 선언문에서. var은 선언 단계와 동시에 일어남.

var 키워드로 선언된 변수를 전역 변수로 사용하면 전역 객체의 프로퍼티가 되지만, let 전역 변수는 보이지 않는 개념적인 블록 내에 존재

const : 상수(변하지 않는 값). const는 반드시 선언과 동시에 할당이 이루어져야 한다

const는 재할당이 금지 = const 변수의 타입이 객체인 경우, 객체에 대한 참조를 변경하지 못한다 but, 객체의 프로퍼티는 보호되지 않는다 -> 객체의 내용(프로퍼티 추가, 삭제, 프로퍼티 값 변경)은 변경 가능

변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. 원시 값의 경우, 가급적 상수를 사용하는 편이 좋다. 그리고 객체를 재할당하는 경우는 생각보다 흔하지 않다. const 키워드를 사용하면 의도치 않은 재할당을 방지해 주기 때문에 보다 안전하다.

<약속>
-ES6를 사용한다면 var 키워드는 사용 X -재할당이 필요한 경우에 한정 -> let 키워드 사용(변수의 스코프는 최대한 좁게) -변경이 발생하지 않는(재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용(const 키워드는 재할당을 금지하므로 var, let 보다 안전) -변수를 선언할 때 일단 const 키워드를 사용(변수를 선언하는 시점에는 재할당이 필요할지 잘 모르는 경우가 많고 객체는 의외로 재할당을 하는 경우가 적음). 반드시 재할당이 필요하다면 그때 const를 let 키워드로 변경해도 O
